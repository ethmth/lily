

# list operations

def sublist(l::int, start:int, end:int) -> int list:
    let new_list::int = []
    let i:int = start
    while (i < end):
        append(new_list, l[i])
        i = i + 1
    return new_list

# sorting functions

def mergesort(l::int) -> int list:
    if (len(l) <= 1):
        return l
    let mid:int = len(l) / 2
    let left::int = mergesort(sublist(l, 0, mid))
    let right::int = mergesort(sublist(l, mid, len(l)))
    return merge(left, right)

def merge(left::int, right::int) -> int list:
    let result::int = []
    while (len(left) > 0 and len(right) > 0):
        if (left[0] < right[0]):
            append(result, pop(left, 0))
        else:
            append(result, pop(right, 0))
    while (len(left) > 0):
        append(result, pop(left, 0))
    while (len(right) > 0):
        append(result, pop(right, 0))
    return result

def quicksort(l::int) -> int list:
    if (len(l) <= 1):
        return l
    let pivot:int = l[len(l) / 2]
    let less::int = []
    let equal::int = []
    let greater::int = []
    for num in l:
        if (num < pivot):
           append(less, num)
        if (num == pivot):
            append(equal, num)
        else:
            append(greater, num)    
    return concatenate(quicksort(less), equal, quicksort(greater))

def selectionsort(l::int) -> int list:
    let length:int = len(l)
    let i:int = 0
    for (i < length, i++):
        let min_idx:int = i
        let j: int = i + 1
        for (j < length, j++):
            if (l[j] < l[min_idx]):
                min_idx = j
        let temp:int = l[i]
        l[i] = l[min_idx]
        l[min_idx] = temp
    return l

# search functions

def binarysearch(l::int, item:int) -> bool:
    let low:int = 0
    let high:int = len(l) - 1
    while (low <= high):
        let mid:int = (low + high) / 2
        if (l[mid] < item):
            low = mid + 1
        if (l[mid] > item):
            high = mid - 1
        else:
            return true
    return false

# multi-list operations

def shuffle(list1::int, list2::int) -> int[]:
    let combined_list::int = []
    let length1:int = len(list1)
    let length2:int = len(list2)
    let i:int = 0
    while (i < length1):
        append(combined_list, list1[i])
        i = i + 1
    i = 0
    while (i < n2):
       append(combined_list, list2[i])
        i = i + 1
    let length:int = len(combined_list)
    let j:int = 0
    let temp:int = 0   
    for (i < length, i++):
        j = random(0, n - 1)
        temp = combined_list[i]
        combined_list[i] = combined_list[j]
        combined_list[j] = temp
    return combined_list