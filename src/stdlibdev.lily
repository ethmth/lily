# sorting functions

def quicksort(l::int) -> int list:
    if (len(l) <= 1):
        return l
    let pivot:int = l[len(l) / 2]
    let less::int = []
    let equal::int = []
    let greater::int = []
    for num in l:
        if (num < pivot):
           append(less, num)
        if (num == pivot):
            append(equal, num)
        else:
            append(greater, num)    
    return concatenate(quicksort(less), equal, quicksort(greater))


# multi-list operations

def shuffle(list1::int, list2::int) -> int[]:
    let combined_list::int = []
    let length1:int = len(list1)
    let length2:int = len(list2)
    let i:int = 0
    while (i < length1):
        append(combined_list, list1[i])
        i = i + 1
    i = 0
    while (i < n2):
       append(combined_list, list2[i])
        i = i + 1
    let length:int = len(combined_list)
    let j:int = 0
    let temp:int = 0   
    for (i < length, i++):
        j = random(0, n - 1)
        temp = combined_list[i]
        combined_list[i] = combined_list[j]
        combined_list[j] = temp
    return combined_list